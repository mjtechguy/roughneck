#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.10"
# dependencies = ["requests>=2.28.0"]
# ///
"""Roughneck - AI-assisted cloud development environment provisioner."""

import sys
import os

# Add lib to path
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from lib import cli, config, terraform, ansible, ssh, credentials
from lib.providers import hetzner, digitalocean, aws


def check_prerequisites() -> bool:
    """Check that required tools are installed."""
    missing = []

    if not terraform.find_terraform_cmd():
        missing.append("tofu or terraform")

    if not ansible.find_ansible_cmd():
        missing.append("ansible-playbook")

    if missing:
        cli.error(f"Missing required tools: {', '.join(missing)}")
        return False
    return True


def prompt_or_select_credentials(provider: str, token_field: str, extra_fields: dict = None) -> dict:
    """Prompt for credentials or select from stored profiles.

    Returns dict with credential values.
    """
    stored = credentials.get_credentials_for_provider(provider)
    result = {}

    if stored:
        choices = [(c.name, c.name) for c in stored]
        choices.append(("new", "[Enter new credentials]"))
        selection = cli.prompt_choice(f"Select {provider} credentials:", choices)

        if selection != "new":
            cred = next(c for c in stored if c.name == selection)
            cli.success(f"Using credentials: {selection}")
            return cred.data
        # Fall through to prompt for new credentials

    # Prompt for new credentials
    if provider == "hetzner":
        result["token"] = cli.prompt_password("Hetzner API token")
    elif provider == "aws":
        result["access_key"] = cli.prompt_password("AWS Access Key")
        result["secret_key"] = cli.prompt_password("AWS Secret Key")
    elif provider == "digitalocean":
        result["token"] = cli.prompt_password("DigitalOcean token")

    # Offer to save (only if age is available)
    if credentials.is_available():
        if cli.prompt_bool("Save these credentials?", default=True):
            name = cli.prompt("Profile name", default=f"{provider}-default")
            credentials.add_credential(name, provider, result)
            cli.success(f"Credentials saved: {name}")

    return result


def prompt_hetzner_config(cfg: config.DeploymentConfig) -> None:
    """Prompt for Hetzner-specific configuration using API."""
    creds = prompt_or_select_credentials("hetzner", "token")
    cfg.hetzner_token = creds["token"]

    # Fetch locations from API
    print("  Fetching locations...")
    try:
        locations = hetzner.get_locations(cfg.hetzner_token)
        location_choices = [(loc["name"], hetzner.format_location(loc)) for loc in locations]
    except hetzner.HetznerAPIError as e:
        cli.error(f"Failed to fetch locations: {e}")
        cfg.hetzner_location = cli.prompt("Location (fsn1, nbg1, hel1, ash, hil)", default="fsn1")
        cfg.hetzner_server_type = cli.prompt("Server type (cx22, cx32, cpx31)", default="cx32")
        return

    cfg.hetzner_location = cli.prompt_choice("Datacenter location:", location_choices, default=1)

    # Fetch server types from API
    print("  Fetching server types...")
    try:
        server_types = hetzner.get_server_types(cfg.hetzner_token, cfg.hetzner_location)
        type_choices = [(st["name"], hetzner.format_server_type(st)) for st in server_types]
        # Find a good default (around 4 vCPU, 8GB RAM)
        default_idx = 1
        for i, st in enumerate(server_types):
            if st["cores"] >= 4 and st["memory"] >= 8:
                default_idx = i + 1
                break
    except hetzner.HetznerAPIError as e:
        cli.error(f"Failed to fetch server types: {e}")
        cfg.hetzner_server_type = cli.prompt("Server type", default="cx32")
        return

    cfg.hetzner_server_type = cli.prompt_choice("Server type:", type_choices, default=default_idx)


def prompt_aws_config(cfg: config.DeploymentConfig) -> None:
    """Prompt for AWS-specific configuration using API."""
    creds = prompt_or_select_credentials("aws", "access_key")
    cfg.aws_access_key = creds["access_key"]
    cfg.aws_secret_key = creds["secret_key"]

    # Fetch regions from API
    print("  Fetching regions...")
    try:
        regions = aws.get_regions(cfg.aws_access_key, cfg.aws_secret_key)
        region_choices = [(r["name"], aws.format_region(r)) for r in regions]
        # Find default (us-east-1)
        default_idx = 1
        for i, r in enumerate(regions):
            if r["name"] == "us-east-1":
                default_idx = i + 1
                break
    except aws.AWSAPIError as e:
        cli.error(f"Failed to fetch regions: {e}")
        cfg.aws_region = cli.prompt("Region", default="us-east-1")
        cfg.aws_instance_type = cli.prompt("Instance type", default="t3.medium")
        return

    cfg.aws_region = cli.prompt_choice("Region:", region_choices, default=default_idx)

    # Fetch instance types from API
    print("  Fetching instance types...")
    try:
        instance_types = aws.get_instance_types(cfg.aws_access_key, cfg.aws_secret_key, cfg.aws_region)
        type_choices = [(t["name"], aws.format_instance_type(t)) for t in instance_types]
        # Find default (t3.medium)
        default_idx = 1
        for i, t in enumerate(instance_types):
            if t["name"] == "t3.medium":
                default_idx = i + 1
                break
    except aws.AWSAPIError as e:
        cli.error(f"Failed to fetch instance types: {e}")
        cfg.aws_instance_type = cli.prompt("Instance type", default="t3.medium")
        return

    cfg.aws_instance_type = cli.prompt_choice("Instance type:", type_choices, default=default_idx)


def prompt_digitalocean_config(cfg: config.DeploymentConfig) -> None:
    """Prompt for DigitalOcean-specific configuration using API."""
    creds = prompt_or_select_credentials("digitalocean", "token")
    cfg.digitalocean_token = creds["token"]

    # Fetch regions from API
    print("  Fetching regions...")
    try:
        regions = digitalocean.get_regions(cfg.digitalocean_token)
        region_choices = [(r["slug"], digitalocean.format_region(r)) for r in regions]
        # Find default (nyc1)
        default_idx = 1
        for i, r in enumerate(regions):
            if r["slug"] == "nyc1":
                default_idx = i + 1
                break
    except digitalocean.DigitalOceanAPIError as e:
        cli.error(f"Failed to fetch regions: {e}")
        cfg.digitalocean_region = cli.prompt("Region", default="nyc1")
        cfg.digitalocean_size = cli.prompt("Droplet size", default="s-2vcpu-4gb")
        return

    cfg.digitalocean_region = cli.prompt_choice("Region:", region_choices, default=default_idx)

    # Fetch sizes from API
    print("  Fetching droplet sizes...")
    try:
        sizes = digitalocean.get_sizes(cfg.digitalocean_token, cfg.digitalocean_region)
        size_choices = [(s["slug"], digitalocean.format_size(s)) for s in sizes]
        # Find default (s-2vcpu-4gb or similar)
        default_idx = 1
        for i, s in enumerate(sizes):
            if s["vcpus"] >= 2 and s["memory"] >= 4096:
                default_idx = i + 1
                break
    except digitalocean.DigitalOceanAPIError as e:
        cli.error(f"Failed to fetch sizes: {e}")
        cfg.digitalocean_size = cli.prompt("Droplet size", default="s-2vcpu-4gb")
        return

    cfg.digitalocean_size = cli.prompt_choice("Droplet size:", size_choices, default=default_idx)


def prompt_new_config(name: str) -> config.DeploymentConfig:
    """Interactively prompt for deployment configuration."""
    cfg = config.DeploymentConfig()

    cli.header("Configuration")

    # Provider selection (first)
    cfg.provider = cli.prompt_choice(
        "Cloud provider:",
        [
            ("hetzner", "Hetzner Cloud"),
            ("aws", "Amazon Web Services"),
            ("digitalocean", "DigitalOcean"),
        ],
        default=1,
    )

    # Provider-specific prompts
    print()
    if cfg.provider == "hetzner":
        prompt_hetzner_config(cfg)
    elif cfg.provider == "aws":
        prompt_aws_config(cfg)
    elif cfg.provider == "digitalocean":
        prompt_digitalocean_config(cfg)

    # Common fields
    print()
    cfg.project_name = cli.prompt("Project name", default=name)

    # SSH key
    print()
    ssh_choice = cli.prompt_choice(
        "SSH key:",
        [
            ("generate", "Generate new key pair"),
            ("existing", "Use existing key"),
        ],
        default=1,
    )
    if ssh_choice == "existing":
        cfg.ssh_public_key_path = cli.prompt("Path to public key", default="~/.ssh/id_rsa.pub")
    else:
        cfg.ssh_public_key_path = ""

    # Firewall config
    print()
    cfg.enable_firewall = cli.prompt_bool("Enable firewall?", default=True)
    if cfg.enable_firewall:
        allowed_ips_str = cli.prompt(
            "Allowed IPs (comma-separated CIDRs, blank for all)",
            required=False,
        )
        if allowed_ips_str:
            cfg.firewall_allowed_ips = [ip.strip() for ip in allowed_ips_str.split(",") if ip.strip()]
        else:
            cfg.firewall_allowed_ips = []

    # Optional features
    print()
    cfg.enable_k9s = cli.prompt_bool("Enable k9s (Kubernetes TUI)?", default=False)
    cfg.enable_gastown = cli.prompt_bool("Enable Gas Town ecosystem?", default=False)
    if cfg.enable_gastown:
        cfg.enable_beads = cli.prompt_bool("Enable beads CLI?", default=False)
        cfg.enable_systemd_services = cli.prompt_bool("Enable systemd services (Mayor/Deacon)?", default=False)

    # TLS Configuration
    print()
    cfg.enable_letsencrypt = cli.prompt_bool("Enable Let's Encrypt TLS (requires domain)?", default=False)
    if cfg.enable_letsencrypt:
        cfg.domain_name = cli.prompt("Domain name (e.g., dev.example.com)")
        while not cfg.domain_name or "." not in cfg.domain_name:
            cli.warn("Please enter a valid domain name")
            cfg.domain_name = cli.prompt("Domain name (e.g., dev.example.com)")

    return cfg


def show_summary(name: str, cfg: config.DeploymentConfig) -> None:
    """Show deployment summary."""
    cli.header("Summary")
    print(f"  Deployment:  {cli.bold(name)}")
    print(f"  Provider:    {cfg.provider}")
    print(f"  Project:     {cfg.project_name}")

    # Provider-specific server info
    if cfg.provider == "hetzner":
        print(f"  Server:      {cfg.hetzner_server_type} in {cfg.hetzner_location}")
    elif cfg.provider == "aws":
        print(f"  Instance:    {cfg.aws_instance_type} in {cfg.aws_region}")
    elif cfg.provider == "digitalocean":
        print(f"  Droplet:     {cfg.digitalocean_size} in {cfg.digitalocean_region}")

    print(f"  SSH key:     {'Generate new' if not cfg.ssh_public_key_path else cfg.ssh_public_key_path}")

    if cfg.enable_firewall:
        if cfg.firewall_allowed_ips:
            print(f"  Firewall:    Restricted to {', '.join(cfg.firewall_allowed_ips)}")
        else:
            print(f"  Firewall:    Enabled (allow all)")
    else:
        print(f"  Firewall:    Disabled")

    # TLS Configuration
    if cfg.enable_letsencrypt:
        print(f"  TLS:         Let's Encrypt ({cfg.domain_name})")
    else:
        print(f"  TLS:         Self-signed certificate")

    # Optional features
    features = []
    if cfg.enable_k9s:
        features.append("k9s")
    if cfg.enable_gastown:
        features.append("Gas Town")
    if cfg.enable_beads:
        features.append("beads")
    if cfg.enable_systemd_services:
        features.append("systemd")
    print(f"  Features:    {', '.join(features) if features else 'None'}")
    print()


def cmd_new(name: str = None) -> int:
    """Create and deploy a new deployment."""
    if not check_prerequisites():
        return 1

    # Get deployment name
    if not name:
        name = cli.prompt("Deployment name")

    if config.deployment_exists(name):
        cli.error(f"Deployment '{name}' already exists")
        print(f"  Use: ./roughneck deploy {name}")
        return 1

    # Get configuration
    cfg = prompt_new_config(name)

    # Show summary
    show_summary(name, cfg)

    if not cli.confirm("Proceed with deployment?"):
        print("Aborted.")
        return 0

    # Save config
    config.write_tfvars(name, cfg)
    cli.success(f"Configuration saved to deployments/{name}/terraform.tfvars")

    # Copy terraform for isolation
    config.copy_terraform_to_deployment(name)

    # Deploy
    return do_deploy(name)


def recovery_menu(stage: str, name: str) -> str:
    """Show recovery options after failure. Returns action to take."""
    options = [("retry", "Retry")]

    if stage in ("apply", "ansible"):
        options.append(("edit", "Edit configuration"))

    if stage in ("apply", "ssh"):
        options.append(("skip", "Skip to next step"))

    options.append(("abort", "Abort (keep current state)"))

    return cli.prompt_choice(f"\n{stage.title()} failed. What would you like to do?", options)


def run_stage(stage: str, name: str) -> bool:
    """Run a single deployment stage. Returns True on success."""
    if stage == "init":
        print("Initializing Terraform...")
        return terraform.init(name)
    elif stage == "apply":
        print("Applying Terraform configuration...")
        return terraform.apply(name)
    elif stage == "ssh":
        ip = config.get_deployment_ip(name)
        if ip:
            print(f"Waiting for SSH on {ip}...")
            return ssh.wait_for_ssh(ip)
        return True  # No IP means skip
    elif stage == "ansible":
        print("Running Ansible playbook...")
        return ansible.run_playbook(name)
    return False


def do_deploy(name: str) -> int:
    """Run terraform and ansible for a deployment with recovery support."""

    # Smart resume: check what's already done
    ip = config.get_deployment_ip(name)
    if ip and ssh.is_reachable(ip):
        cli.info(f"Server {ip} already running, skipping to configuration...")
        stages = ["ansible"]
    elif ip:
        cli.info(f"Server {ip} exists but not reachable, waiting for SSH...")
        stages = ["ssh", "ansible"]
    elif config.has_state_file(name):
        cli.info("Partial state found, resuming terraform apply...")
        stages = ["apply", "ssh", "ansible"]
    else:
        cli.header("Provisioning Infrastructure")
        stages = ["init", "apply", "ssh", "ansible"]

    stage_idx = 0
    while stage_idx < len(stages):
        stage = stages[stage_idx]

        if run_stage(stage, name):
            # Success - move to next stage
            if stage == "apply":
                cli.success("Infrastructure provisioned")

                # DNS pause for Let's Encrypt
                ip = config.get_deployment_ip(name)
                cfg = config.read_tfvars(name)
                if cfg and cfg.enable_letsencrypt and cfg.domain_name and ip:
                    print()
                    cli.header("DNS Configuration Required")
                    print(f"  Server IP: {cli.cyan(ip)}")
                    print(f"  Domain:    {cli.cyan(cfg.domain_name)}")
                    print()
                    print("  Before continuing, configure your DNS:")
                    print(f"    {cfg.domain_name}  →  A record  →  {ip}")
                    print()
                    if not cli.confirm("DNS configured and propagated?"):
                        cli.info("Deployment paused. Run './roughneck deploy' to resume.")
                        return 1

            elif stage == "ansible":
                cli.success("Server configured")
            stage_idx += 1
        else:
            # Failure - show recovery menu
            cli.error(f"{stage.title()} failed")
            action = recovery_menu(stage, name)

            if action == "retry":
                continue  # Retry same stage
            elif action == "edit":
                tfvars_path = config.get_tfvars_path(name)
                cli.open_editor(tfvars_path)
                print()
                continue  # Retry after edit
            elif action == "skip":
                stage_idx += 1  # Move to next stage
            else:  # abort
                cli.info("Deployment paused. Run './roughneck deploy' to resume.")
                return 1

    # Done
    ip = config.get_deployment_ip(name)
    deploy_dir = config.get_deployment_dir(name)
    summary_file = deploy_dir / "installation-summary.txt"
    cfg = config.read_tfvars(name)

    cli.header("Deployment Complete")
    ssh_cmd = ssh.get_ssh_command(name)
    if ssh_cmd:
        print(f"  SSH:         {cli.cyan(ssh_cmd)}")
    if cfg and cfg.enable_letsencrypt and cfg.domain_name:
        print(f"  Code-server: {cli.cyan(f'https://{cfg.domain_name}')}  (Let's Encrypt)")
    elif ip:
        print(f"  Code-server: {cli.cyan(f'https://{ip}:10000')}  (self-signed cert)")
    print()
    if summary_file.exists():
        print(f"  Full details: {summary_file}")
    print()

    return 0


def cmd_deploy(name: str = None) -> int:
    """Deploy an existing deployment."""
    if not check_prerequisites():
        return 1

    # Get deployment name
    if not name:
        deployments = config.list_deployments()
        if not deployments:
            cli.error("No deployments found")
            print("  Create one with: ./roughneck new")
            return 1
        name = cli.select_from_list("Select deployment:", deployments)
        if not name:
            return 1

    if not config.deployment_exists(name):
        cli.error(f"Deployment '{name}' not found")
        print("  Create it with: ./roughneck new")
        return 1

    return do_deploy(name)


def cmd_destroy(name: str = None) -> int:
    """Destroy a deployment."""
    if not check_prerequisites():
        return 1

    # Get deployment name
    if not name:
        deployments = config.list_deployments()
        if not deployments:
            cli.error("No deployments found")
            return 1
        name = cli.select_from_list("Select deployment to destroy:", deployments)
        if not name:
            return 1

    if not config.deployment_exists(name):
        cli.error(f"Deployment '{name}' not found")
        return 1

    cli.header(f"Destroy: {name}")
    ip = config.get_deployment_ip(name)
    provider = config.get_deployment_provider(name)
    if provider:
        print(f"  Provider:  {provider}")
    if ip:
        print(f"  Server IP: {ip}")
    print()

    cli.warn("This will permanently destroy all infrastructure!")
    print()
    print(f"  Type '{name}' to confirm: ", end="")
    confirmation = input().strip()
    if confirmation != name:
        cli.error("Name does not match. Aborted.")
        return 0

    cli.header("Destroying Infrastructure")

    if not terraform.destroy(name):
        cli.error("Terraform destroy failed")
        return 1

    # Clean up deployment folder
    config.delete_deployment(name)
    cli.success(f"Deployment '{name}' destroyed")

    return 0


def cmd_list() -> int:
    """List all deployments."""
    cli.header("Deployments")

    deployments = config.list_deployments()
    if not deployments:
        print("  No deployments found.")
        print()
        print("  Create one with: ./roughneck new")
        print()
        return 0

    for name in deployments:
        ip = config.get_deployment_ip(name)
        provider = config.get_deployment_provider(name) or "unknown"
        if ip:
            print(f"  {name} ({provider}): {cli.green(ip)}")
        else:
            print(f"  {name} ({provider}): {cli.yellow('(not deployed)')}")

    print()
    return 0


def cmd_ssh(name: str = None) -> int:
    """SSH to a deployment."""
    # Get deployment name
    if not name:
        deployments = config.list_deployments()
        deployed = [d for d in deployments if config.get_deployment_ip(d)]
        if not deployed:
            cli.error("No deployed servers found")
            return 1
        name = cli.select_from_list("Select deployment:", deployed)
        if not name:
            return 1

    if not config.get_deployment_ip(name):
        cli.error(f"Deployment '{name}' has no IP (not deployed?)")
        return 1

    # This will exec ssh and not return
    if not ssh.connect(name):
        cli.error("Failed to connect")
        return 1

    return 0


def cmd_edit(name: str = None) -> int:
    """Edit a deployment's configuration."""
    # Get deployment name
    if not name:
        deployments = config.list_deployments()
        if not deployments:
            cli.error("No deployments found")
            return 1
        name = cli.select_from_list("Select deployment to edit:", deployments)
        if not name:
            return 1

    if not config.deployment_exists(name):
        cli.error(f"Deployment '{name}' not found")
        return 1

    tfvars_path = config.get_tfvars_path(name)
    cli.info(f"Editing {tfvars_path}")
    if cli.open_editor(tfvars_path):
        cli.success("Configuration saved")
        if cli.confirm("Deploy now?", default=False):
            return do_deploy(name)
    return 0


def cmd_update(name: str = None) -> int:
    """Update an existing deployment."""
    if not check_prerequisites():
        return 1

    # Get deployment name
    if not name:
        deployments = config.list_deployments()
        deployed = [d for d in deployments if config.get_deployment_ip(d)]
        if not deployed:
            cli.error("No deployed servers found")
            print("  Create one with: ./roughneck new")
            return 1
        name = cli.select_from_list("Select deployment to update:", deployed)
        if not name:
            return 1

    ip = config.get_deployment_ip(name)
    if not ip:
        cli.error(f"Deployment '{name}' has no IP (not deployed?)")
        return 1

    # Select what to update
    cli.header("Update Options")
    updates = []

    if cli.prompt_bool("Update system packages (apt)?", default=True):
        updates.append("apt")
    if cli.prompt_bool("Update AI CLIs (Claude, Codex, Gemini)?", default=True):
        updates.append("ai_clis")
    if cli.prompt_bool("Update dev tools (lazygit, lazydocker)?", default=False):
        updates.append("dev_tools")

    if not updates:
        cli.info("Nothing selected to update")
        return 0

    # Run update playbook with tags
    cli.header(f"Updating: {name}")
    if ansible.run_update_playbook(name, updates):
        cli.success("Update complete")
        return 0
    else:
        cli.error("Update failed")
        return 1


def cmd_credentials() -> int:
    """Manage stored credentials."""
    if not credentials.is_available():
        cli.header("age Installation Required")
        print("  Credential storage uses age encryption.")
        print("  Install age to enable this feature:")
        print()
        print("  macOS:")
        print("    brew install age")
        print()
        print("  Linux (Debian/Ubuntu):")
        print("    sudo apt install age")
        print()
        print("  Linux (Fedora):")
        print("    sudo dnf install age")
        print()
        print("  Or download from: https://github.com/FiloSottile/age/releases")
        print()
        return 1

    while True:
        creds = credentials.load_credentials()

        cli.header("Stored Credentials")
        if creds:
            for c in creds:
                print(f"  {c.name} ({c.provider})")
        else:
            print("  No credentials stored")
        print()

        action = cli.prompt_choice(
            "Action:",
            [
                ("add", "Add new credentials"),
                ("remove", "Remove credentials"),
                ("back", "Back to main menu"),
            ],
        )

        if action == "back":
            return 0
        elif action == "add":
            provider = cli.prompt_choice(
                "Provider:",
                [
                    ("hetzner", "Hetzner Cloud"),
                    ("aws", "Amazon Web Services"),
                    ("digitalocean", "DigitalOcean"),
                ],
            )
            name = cli.prompt("Profile name")

            if provider == "hetzner":
                token = cli.prompt_password("Hetzner API token")
                credentials.add_credential(name, provider, {"token": token})
            elif provider == "aws":
                access_key = cli.prompt_password("AWS Access Key")
                secret_key = cli.prompt_password("AWS Secret Key")
                credentials.add_credential(
                    name, provider, {"access_key": access_key, "secret_key": secret_key}
                )
            elif provider == "digitalocean":
                token = cli.prompt_password("DigitalOcean token")
                credentials.add_credential(name, provider, {"token": token})

            cli.success(f"Credentials saved: {name}")

        elif action == "remove":
            if not creds:
                cli.warn("No credentials to remove")
                continue
            choices = [(c.name, f"{c.name} ({c.provider})") for c in creds]
            name = cli.prompt_choice("Select credential to remove:", choices)
            if cli.confirm(f"Remove '{name}'?", default=False):
                credentials.remove_credential(name)
                cli.success(f"Removed: {name}")


def interactive_menu() -> int:
    """Show interactive menu."""
    action = cli.menu(
        "Roughneck",
        [
            ("new", "Create new deployment"),
            ("update", "Update deployment"),
            ("edit", "Edit configuration"),
            ("destroy", "Destroy deployment"),
            ("list", "List deployments"),
            ("ssh", "SSH to deployment"),
            ("credentials", "Manage credentials"),
        ],
    )

    if action == "new":
        return cmd_new()
    elif action == "update":
        return cmd_update()
    elif action == "edit":
        return cmd_edit()
    elif action == "destroy":
        return cmd_destroy()
    elif action == "list":
        return cmd_list()
    elif action == "ssh":
        return cmd_ssh()
    elif action == "credentials":
        return cmd_credentials()
    return 0


def main() -> int:
    """Main entry point."""
    args = sys.argv[1:]

    # No args = interactive menu
    if not args:
        return interactive_menu()

    cmd = args[0]
    name = args[1] if len(args) > 1 else None

    if cmd == "new":
        return cmd_new(name)
    elif cmd == "update":
        return cmd_update(name)
    elif cmd == "deploy":
        return cmd_deploy(name)
    elif cmd == "edit":
        return cmd_edit(name)
    elif cmd == "destroy":
        return cmd_destroy(name)
    elif cmd == "list":
        return cmd_list()
    elif cmd == "ssh":
        return cmd_ssh(name)
    elif cmd == "credentials":
        return cmd_credentials()
    elif cmd in ("-h", "--help", "help"):
        print("Usage: roughneck [command] [name]")
        print()
        print("Commands:")
        print("  new [name]      Create new deployment")
        print("  update [name]   Update deployment (apt, AI CLIs, dev tools)")
        print("  deploy [name]   Deploy existing (with recovery)")
        print("  edit [name]     Edit deployment configuration")
        print("  destroy [name]  Destroy deployment")
        print("  list            List deployments")
        print("  ssh [name]      SSH to deployment")
        print("  credentials     Manage stored credentials")
        print()
        print("Supported providers: hetzner, aws, digitalocean")
        print()
        print("Run without arguments for interactive menu.")
        return 0
    else:
        cli.error(f"Unknown command: {cmd}")
        print("  Run ./roughneck --help for usage")
        return 1


if __name__ == "__main__":
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        print("\nAborted.")
        sys.exit(1)
